!$SH source fortran.bpp.sh

!$SH # the maximum dimension of array handled here
!$SH MAXDIM=7

!$SH # Returns the VELOC_Mem type associated to the type descriptor $1
!$SH function velec_mem_type {
!$SH   echo "VELOC_Mem_${1}"
!$SH }

module VELOC_Mem

  use ISO_C_BINDING

  private


  type, public :: VELOC_Mem_type

    private
    type(c_ptr) :: raw_type

  endtype VELOC_Mem_type



  !> Token returned if a VELOC_Mem function succeeds.
  integer, parameter :: VELOC_Mem_SCES = 0
  !> Token returned if a VELOC_Mem function fails.
  integer, parameter :: VELOC_Mem_NSCS = -1



!$SH for T in ${FORTTYPES}; do
  type(VELOC_Mem_type) :: $(velec_mem_type ${T})
!$SH done



  public :: VELOC_Mem_SCES, VELOC_Mem_NSCS, &
!$SH for T in ${FORTTYPES}; do
      $(velec_mem_type ${T}), &
!$SH done
      VELOC_Mem_Init, VELOC_Mem_Status, VELOC_Mem_InitType, VELOC_Mem_Protect,  &
      VELOC_Mem_Checkpoint, VELOC_Mem_Recover, VELOC_Mem_Snapshot, VELOC_Mem_Finalize



  interface

    function VELOC_Mem_Init_impl(config_file, global_comm) &
            bind(c, name='VELOC_Mem_Init_fort_wrapper')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_Init_impl
      character(c_char), intent(IN) :: config_file(*)
      integer(c_int), intent(INOUT) :: global_comm

    endfunction VELOC_Mem_Init_impl

  endinterface



  interface

    function VELOC_Mem_Status_impl() &
            bind(c, name='VELOC_Mem_Status')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_Status_impl

    endfunction VELOC_Mem_Status_impl

  endinterface



  interface

    function VELOC_Mem_InitType_impl(type_F, size_F) &
            bind(c, name='VELOC_Mem_InitType_wrapper')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_InitType_impl
      type(c_ptr), intent(OUT) :: type_F
      integer(c_int), value :: size_F

    endfunction VELOC_Mem_InitType_impl

  endinterface



  interface

    function VELOC_Mem_Protect_impl(id_F, ptr, count_F, type_F) &
            bind(c, name='VELOC_Mem_Protect_wrapper')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_Protect_impl
      integer(c_int), value :: id_F
      type(c_ptr), value :: ptr
      integer(c_long), value :: count_F
      type(c_ptr), value :: type_F

    endfunction VELOC_Mem_Protect_impl

  endinterface



  interface

    function VELOC_Mem_Checkpoint_impl(id_F, level) &
            bind(c, name='VELOC_Mem_Checkpoint')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_Checkpoint_impl
      integer(c_int), value :: id_F
      integer(c_int), value :: level

    endfunction VELOC_Mem_Checkpoint_impl

  endinterface



  interface

    function VELOC_Mem_Recover_impl() &
            bind(c, name='VELOC_Mem_Recover')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_Recover_impl

    endfunction VELOC_Mem_Recover_impl

  endinterface



  interface

    function VELOC_Mem_Snapshot_impl() &
            bind(c, name='VELOC_Mem_Snapshot')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_Snapshot_impl

    endfunction VELOC_Mem_Snapshot_impl

  endinterface



  interface

    function VELOC_Mem_Finalize_impl() &
            bind(c, name='VELOC_Mem_Finalize')

      use ISO_C_BINDING

      integer(c_int) :: VELOC_Mem_Finalize_impl

    endfunction VELOC_Mem_Finalize_impl

  endinterface



  interface VELOC_Mem_Protect

    module procedure VELOC_Mem_Protect_Ptr
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
    module procedure VELOC_Mem_Protect_${T}${D}
!$SH   done
!$SH done

  endinterface VELOC_Mem_Protect


contains

  subroutine VELOC_Mem_Init(config_file, global_comm, err)

    include 'mpif.h'

    character(len=*), intent(IN) :: config_file
    integer, intent(INOUT) :: global_comm
    integer, intent(OUT) :: err

    character, target, dimension(1:len_trim(config_file)+1) :: config_file_c
    integer :: ii, ll
    integer(c_int) :: global_comm_c

    ll = len_trim(config_file)
    do ii = 1, ll
      config_file_c(ii) = config_file(ii:ii)
    enddo
    config_file_c(ll+1) = c_null_char
    global_comm_c = int(global_comm, c_int)
    err = int(VELOC_Mem_Init_impl(config_file_c, global_comm_c))
    global_comm = int(global_comm_c)
    if (err /= VELOC_Mem_SCES ) then
      return
    endif

!$SH for T in ${FORTTYPES}; do
    call VELOC_Mem_InitType($(velec_mem_type ${T}), int($(fort_sizeof ${T})_C_int/8_c_int, C_int), err)
    if (err /= VELOC_Mem_SCES ) then
      return
    endif
!$SH done

  endsubroutine VELOC_Mem_Init



  subroutine VELOC_Mem_Status(status)

    integer, intent(OUT) :: status

    status = int(VELOC_Mem_Status_impl())

  endsubroutine VELOC_Mem_Status



  subroutine VELOC_Mem_InitType(type_F, size_F, err)

    type(VELOC_Mem_type), intent(OUT) :: type_F
    integer, intent(IN) :: size_F
    integer, intent(OUT) :: err

    err = int(VELOC_Mem_InitType_impl(type_F%raw_type, int(size_F, c_int)))

  endsubroutine VELOC_Mem_InitType



  subroutine VELOC_Mem_Protect_Ptr(id_F, ptr, count_F, type_F, err)

    integer, intent(IN) :: id_F
    type(c_ptr), value :: ptr
    integer, intent(IN) :: count_F
    type(VELOC_Mem_type), intent(IN) :: type_F
    integer, intent(OUT) :: err

    err = int(VELOC_Mem_Protect_impl(int(id_F, c_int), ptr, int(count_F, c_long), &
            type_F%raw_type))

  endsubroutine VELOC_Mem_Protect_Ptr


!$SH for T in ${FORTTYPES}; do

  subroutine VELOC_Mem_Protect_${T}0(id_F, data, err)

    integer, intent(IN) :: id_F
    $(fort_type ${T}), pointer :: data
    integer, intent(OUT) :: err

    call VELOC_Mem_Protect_Ptr(id_F, c_loc(data), 1, $(velec_mem_type ${T}), err)

  endsubroutine VELOC_Mem_Protect_${T}0


!$SH   for D in $(seq 1 ${MAXDIM}); do

  subroutine VELOC_Mem_Protect_${T}${D}(id_F, data, err)

    integer, intent(IN) :: id_F
    $(fort_type ${T}), pointer :: data$(str_repeat ':' 1 ${D} ',' '(' ')')
    integer, intent(OUT) :: err

    ! workaround, we take the address of the first array element and hope for
    ! the best since not much better can be done
    call VELOC_Mem_Protect_Ptr(id_F, &
            c_loc(data$(str_repeat 'lbound(data, @N)' 1 ${D} $',&\n' '(' ')')), &
            size(data), $(velec_mem_type ${T}), err)

  endsubroutine VELOC_Mem_Protect_${T}${D}


!$SH   done
!$SH done

  subroutine VELOC_Mem_Checkpoint(id_F, level, err)

    integer, intent(IN) :: id_F
    integer, intent(IN) :: level
    integer, intent(OUT) :: err

    err = int(VELOC_Mem_Checkpoint_impl(int(id_F, c_int), int(level, c_int)))

  endsubroutine VELOC_Mem_Checkpoint



  subroutine VELOC_Mem_Recover(err)

    integer, intent(OUT) :: err

    err = int(VELOC_Mem_Recover_impl())

  endsubroutine VELOC_Mem_Recover



  subroutine VELOC_Mem_Snapshot(err)

    integer, intent(OUT) :: err

    err = int(VELOC_Mem_Snapshot_impl())

  endsubroutine VELOC_Mem_Snapshot



  subroutine VELOC_Mem_Finalize(err)

    integer, intent(OUT) :: err

    err = int(VELOC_Mem_Finalize_impl())

  endsubroutine VELOC_Mem_Finalize

endmodule VELOC_Mem
